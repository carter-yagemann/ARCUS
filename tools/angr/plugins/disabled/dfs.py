#!/usr/bin/env python
#
# Copyright 2020 Carter Yagemann
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import logging

import explore

from angr.exploration_techniques import ExplorationTechnique

log = logging.getLogger(__name__)

class DFSExplorer(ExplorationTechnique):
    """Searches for bugs using a depth-first search (DFS) approach.

    Keyword Args:
    predecessors -- The list of states generated by Tracer.
    trace -- The list of basic block addresses in the original PT trace.
    """

    def __init__(self, predecessors, trace, options):
        super(DFSExplorer, self).__init__()
        self.orig_preds = predecessors
        self.predecessors = predecessors
        self.trace = trace
        self.queue = list()

    def setup(self, simgr):
        """Sets up the exploration"""
        log.info("Setting up explorer...")

        if not 'missed' in simgr.stashes:
            simgr.populate('missed', [])
        simgr.drop(stash='active')

        for idx, state in enumerate(self.predecessors):
            self.queue.append((state, self.predecessors[:idx - 1].copy()))
        self._rewind(simgr, setup=True)

    def step(self, simgr, stash='active', **kwargs):
        simgr.drop(stash='missed')

        # this can happen if a detector plugin removes our active state because
        # further execution is no longer possible (e.g., symbolic IP)
        if len(simgr.stashes['active']) < 1:
            log.debug("No more active states, rewinding")
            self._rewind(simgr)

        return simgr.step(stash=stash, **kwargs)

    def step_state(self, simgr, state, **kwargs):
        # maintain the predecessors list
        self.predecessors.append(state)
        succs = {'active': [], 'missed': []}

        # describe where the state currently is in the program
        loader = self.project.loader
        if loader.find_object_containing(state.addr):
            loc_desc = loader.describe_addr(state.addr)
        else:
            loc_desc = "%#x" % state.addr

        # log location and stats
        log.info("DFS Explorer: (%d) %s", len(self.queue), loc_desc)

        # get satisfiable successors to this state (otherwise we're stuck)
        try:
            candidates = [succ for succ in state.step() if succ.solver.satisfiable()]
        except Exception as ex:
            # state cannot be stepped, we're done with this run
            log.debug("Cannot step (%s), rewinding" % str(ex))
            self._rewind(simgr)
            if len(simgr.stashes['active']) > 0:
                succs['active'] = [simgr.stashes['active'][0]]
            return succs

        # update stats in candidates
        for can in candidates:
            can_desc = loader.describe_addr(can.addr)
            if not 'register_tm_clones' in can_desc:
                succs['active'].append(can)

        # the active stash can only have 1 state at a time, if we have more,
        # we'll queue the rest up for later
        if len(succs['active']) > 1:
            for succ in succs['active'][1:]:
                self.queue.append((succ, self.predecessors.copy()))
            succs['active'] = [succs['active'][0]]

        return succs

    def complete(self, simgr):
        """Returns True when there's nothing left to explore"""
        return len(simgr.stashes['active']) < 1 and len(self.queue) < 1

    def _rewind(self, simgr, setup=False):
        """Queues up the next candidate by rewinding and then setting it as active"""
        simgr.drop(stash='active')
        try:
            state, preds = self.queue.pop()
        except IndexError:
            log.info("No pending states left")
            return

        simgr.stashes['active'] = [state.copy()]
        self.predecessors = preds

explorer = DFSExplorer
