#!/usr/bin/env python
#
# Copyright 2020 Carter Yagemann
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import logging

import explore

from angr.exploration_techniques import ExplorationTechnique

log = logging.getLogger(__name__)


class BFSExplorer(ExplorationTechnique):
    """Searches for bugs using a breath-first search (BFS) approach.

    Keyword Args:
    predecessors -- The list of states generated by Tracer.
    trace -- The list of basic block addresses in the original PT trace.
    """

    def __init__(self, predecessors, trace, options):
        super(BFSExplorer, self).__init__()
        self.orig_preds = predecessors
        self.predecessors = predecessors
        self.trace = trace
        self.queue = list()

    def setup(self, simgr):
        """Sets up the exploration"""
        log.info("Setting up explorer...")

        if not "missed" in simgr.stashes:
            simgr.populate("missed", [])
        simgr.drop(stash="active")

        for idx, state in enumerate(self.predecessors):
            self.queue.append((state, self.predecessors[: idx - 1].copy()))
        self._rewind(simgr, setup=True)

    def step(self, simgr, stash="active", **kwargs):
        simgr.drop(stash="missed")

        # this can happen if a detector plugin removes our active state because
        # further execution is no longer possible (e.g., symbolic IP)
        if len(simgr.stashes["active"]) < 1:
            log.debug("No more active states, rewinding")
            self._rewind(simgr)

        return simgr.step(stash=stash, **kwargs)

    def step_state(self, simgr, state, **kwargs):
        # maintain the predecessors list
        self.predecessors.append(state)
        succs = {"active": [], "missed": []}

        # describe where the state currently is in the program
        loader = self.project.loader
        if loader.find_object_containing(state.addr):
            loc_desc = loader.describe_addr(state.addr)
        else:
            loc_desc = "%#x" % state.addr

        # log location and stats
        log.info("BFS Explorer: (%d) %s", len(self.queue), loc_desc)

        # get satisfiable successors to this state (otherwise we're stuck)
        try:
            candidates = [succ for succ in state.step() if succ.solver.satisfiable()]
        except Exception as ex:
            # state cannot be stepped, we're done with this run
            log.debug("Cannot step (%s), rewinding" % str(ex))
            self._rewind(simgr)
            if len(simgr.stashes["active"]) > 0:
                succs["active"] = [simgr.stashes["active"][0]]
            return succs

        # update stats in candidates
        for can in candidates:
            can_desc = loader.describe_addr(can.addr)
            if not "register_tm_clones" in can_desc:
                succs["active"].append(can)

        # the active stash can only have 1 state at a time, if we have more,
        # we'll queue the rest up for later
        if len(succs["active"]) > 1:
            for succ in succs["active"][1:]:
                self.queue.insert(0, (succ, self.predecessors.copy()))
            succs["active"] = [succs["active"][0]]

        return succs

    def complete(self, simgr):
        """Returns True when there's nothing left to explore"""
        return len(simgr.stashes["active"]) < 1 and len(self.queue) < 1

    def _rewind(self, simgr, setup=False):
        """Queues up the next candidate by rewinding and then setting it as active"""
        simgr.drop(stash="active")
        try:
            state, preds = self.queue.pop()
        except IndexError:
            log.info("No pending states left")
            return

        simgr.stashes["active"] = [state.copy()]
        self.predecessors = preds


explorer = BFSExplorer
