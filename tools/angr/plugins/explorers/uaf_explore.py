#!/usr/bin/env python
#
# Copyright 2020 Carter Yagemann
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import logging

import explore
import taint

from angr.exploration_techniques import ExplorationTechnique
from cle.address_translator import AT
from cle.backends import ELF
import networkx

log = logging.getLogger(__name__)


class CFGNode(object):
    def __init__(self, state):
        self.addr = state.addr
        self.loader = state.project.loader
        self._get_desc()

    def _get_desc(self):
        addr = self.addr
        obj = self.loader.find_object_containing(addr)
        if obj is None:
            self.desc = hex(addr)
        else:
            options = list()
            rva = AT.from_va(addr, obj).to_rva()

            idx = obj.symbols.bisect_key_right(rva) - 1
            while idx >= 0:
                sym = obj.symbols[idx]
                if not sym.name or sym.is_import:
                    idx -= 1
                    continue
                options.append((sym.relative_addr, "%s+" % sym.name))
                break

            if isinstance(obj, ELF):
                try:
                    plt_addr, plt_name = max(
                        (a, n) for n, a in obj._plt.items() if a <= rva
                    )
                except ValueError:
                    pass
                else:
                    options.append((plt_addr, "PLT.%s+" % plt_name))

            options.append((0, "offset "))
            best_offset, best_prefix = max(options, key=lambda v: v[0])
            self.desc = "%s%#x (%#x)" % (
                best_prefix,
                rva - best_offset,
                AT.from_va(addr, obj).to_lva(),
            )

    def __repr__(self):
        return "<CFGNode %s>" % self.desc

    def __str__(self):
        return "<CFGNode %s>" % self.desc

    def __hash__(self):
        return self.addr

    def __eq__(self, other):
        return isinstance(other, CFGNode) and self.addr == other.addr

    def __ne__(self, other):
        return not self == other


class UAFExplorer(ExplorationTechnique):
    """Searches for use-after-free and double-free (which is treated as a
    special subset of UAF) bugs.

    This explorer's strategy is to first find all functions that manipulate
    heap data, then explore them to find alternative paths beyond what was
    initially traced.

    The allocations issues detector (allocation_issues.py) must be enabled for
    this plugin to work correctly.

    Keyword Args:
    predecessors -- The list of states generated by Tracer.
    trace -- The list of basic block addresses in the original PT trace.
    """

    def __init__(self, predecessors, trace, options):
        super(UAFExplorer, self).__init__()
        self.orig_preds = predecessors
        self.predecessors = predecessors
        self.trace = trace
        self.queue = list()
        self.graph = networkx.DiGraph()
        # tunable parameters
        self.step_limit = 50
        self.ctx_sensitivity = 15

    def setup(self, simgr):
        """Sets up the exploration"""
        # this explorer needs the points-to info collected by the allocation issues
        # detector; if it's not available, bail
        last_state = self.predecessors[-1]
        if not (hasattr(last_state, "deep") and "points_to" in last_state.deep):
            log.error(
                "Cannot find points-to metadata in states, is the allocation"
                "issues plugin (allocation_issues.py) enabled?"
            )
            return

        log.info("Setting up explorer...")

        if not "missed" in simgr.stashes:
            simgr.populate("missed", [])
        simgr.drop(stash="active")

        # We need to identify all the states associated with "functions" that manipulate
        # heap data. We use the term "function" loosely here because they are a source
        # code construct, not binary. Tracking call and return instructions is a
        # good enough approximation. Optimizations like inlining merely cause us to
        # explore more states.
        touches_heap = [False] * len(self.predecessors)
        touching_heap = [False]
        for idx, pred in enumerate(self.predecessors[:-1]):
            # we'll need the successor state for determining memory accesses
            succ = self.predecessors[idx + 1]

            if pred.history.jumpkind.startswith("Ijk_Call"):
                # state just called, push a new touching_heap onto our "stack"
                touching_heap.append(False)
            elif pred.history.jumpkind.startswith("Ijk_Ret") and len(touching_heap) > 1:
                # state returned, pop so we remember whether the prior function was
                # manipulating heap
                touching_heap.pop()

            if len(pred.deep["points_to"]) < 1:
                # state has no active pointers, not touching heap
                touches_heap[idx] = False
            elif touching_heap[-1]:
                # function already touching heap, this state is automatically considered touching
                touches_heap[idx] = True
            elif self._touches_heap(pred, succ):
                # first state in the function to touch heap
                touches_heap[idx] = True
                touching_heap[-1] = True

        log.debug("       States that touch heap: %d" % touches_heap.count(True))
        log.debug("States that do not touch heap: %d" % touches_heap.count(False))

        for idx, state in enumerate(self.predecessors):
            if touches_heap[idx]:
                self.queue.append((state, self.predecessors[: idx - 1].copy()))
        self._rewind(simgr, setup=True)

    def step(self, simgr, stash="active", **kwargs):
        simgr.drop(stash="missed")

        # this can happen if a detector plugin removes our active state because
        # further execution is no longer possible (e.g., symbolic IP)
        if len(simgr.stashes["active"]) < 1:
            log.debug("No more active states, rewinding")
            self._rewind(simgr)

        return simgr.step(stash=stash, **kwargs)

    def step_state(self, simgr, state, **kwargs):
        # maintain the predecessors list
        self.predecessors.append(state)
        succs = {"active": [], "missed": []}

        # describe where the state currently is in the program
        loader = self.project.loader
        if loader.find_object_containing(state.addr):
            loc_desc = loader.describe_addr(state.addr)
        else:
            loc_desc = "%#x" % state.addr

        # log location and stats
        log.info(
            "UAF Explorer: (%d) %d/%d %s",
            len(self.queue),
            state.globals["uaf_explore_steps"],
            self.step_limit,
            loc_desc,
        )

        # we've reached the step limit, rewind
        if state.globals["uaf_explore_steps"] >= self.step_limit:
            self._rewind(simgr)
            if len(simgr.stashes["active"]) > 0:
                succs["active"] = [simgr.stashes["active"][0]]
            return succs

        # get satisfiable successors to this state (otherwise we're stuck)
        try:
            candidates = [succ for succ in state.step() if succ.solver.satisfiable()]
        except Exception as ex:
            # state cannot be stepped, we're done with this run
            log.debug("Cannot step (%s), rewinding" % str(ex))
            self._rewind(simgr)
            if len(simgr.stashes["active"]) > 0:
                succs["active"] = [simgr.stashes["active"][0]]
            return succs

        # update stats in candidates
        # filter candidates based on context sensitivity and other heuristics
        for can in candidates:
            can.globals["uaf_explore_steps"] += 1

            if can.globals["uaf_explore_steps"] == 1 and can.addr in self.trace:
                # we want paths we haven't already explored, not interested in
                # states where the first step stays on the traced path
                succs["missed"].append(can)
            elif self._already_explored(can, self.predecessors):
                succs["missed"].append(can)
            else:
                succs["active"].append(can)

        # the active stash can only have 1 state at a time, if we have more,
        # we'll queue the rest up for later
        if len(succs["active"]) > 1:
            for succ in succs["active"][1:]:
                self.queue.append((succ, self.predecessors.copy()))
            succs["active"] = [succs["active"][0]]

        return succs

    def complete(self, simgr):
        """Returns True when there's nothing left to explore"""
        return len(simgr.stashes["active"]) < 1 and len(self.queue) < 1

    def _rewind(self, simgr, setup=False):
        """Queues up the next candidate by rewinding and then setting it as active"""
        if not setup:
            self._update_graph(self.predecessors)

        simgr.drop(stash="active")
        try:
            state, preds = self.queue.pop()
        except IndexError:
            log.info("No pending states left")
            return

        state.globals["uaf_explore_steps"] = 0
        simgr.stashes["active"] = [state.copy()]
        self.predecessors = preds

    def _touches_heap(self, state, successor):
        """Given a state and its successor state, determine whether it touches heap.

        Note, this method currently depends on POSIX OS semantics and will not work
        on states simulating non-POSIX environments. It also assumes an upward growing
        heap. It is suitable for Linux environments.

        Keyword Arguments:
        state -- The state to examine.
        successor -- Its successor state (used to avoid resolving ASTs).

        Returns:
        True if state touches the heap, otherwise False.
        """
        for tmp, ast in taint.get_mem_accesses(state, successor):
            if state.solver.is_true(ast <= state.posix.brk):
                return True

        return False

    def _update_graph(self, preds):
        """Update our internal CFG using the provided list of predecessor states."""
        if len(preds) < 1:
            return

        for idx, state in enumerate(preds):
            node = CFGNode(state)
            if not node in self.graph.nodes:
                self.graph.add_node(node)
            if idx > 0:  # first node has no precedessors
                prev = CFGNode(preds[idx - 1])
                self.graph.add_edge(prev, node)

    def _already_explored(self, state, preds):
        """Decides whether the following execution path has already been explored
        based on the current state, its predecessors, and the internally maintained
        CFG.

        Returns:
        True if path is not "novel", otherwise False.
        """
        path = list()
        for pred in preds[-self.ctx_sensitivity :]:
            path.append(CFGNode(pred))
        path.append(CFGNode(state))

        for idx, node in enumerate(path[1:]):
            if not self.graph.has_edge(path[idx], node):
                return False

        return True


explorer = UAFExplorer
